// Generated by Haxe 3.4.2
using haxe.root;

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.root {
	public class EyeHeadGazeLogic : global::haxe.lang.HxObject {
		
		static EyeHeadGazeLogic() {
			unchecked {
				global::haxe.root.EyeHeadGazeLogic.EYES_RIGHT = "Expressions_eyesHoriz_min";
				global::haxe.root.EyeHeadGazeLogic.EYES_LEFT = "Expressions_eyesHoriz_max";
				global::haxe.root.EyeHeadGazeLogic.EYES_DOWN = "Expressions_eyesVert_min";
				global::haxe.root.EyeHeadGazeLogic.EYES_UP = "Expressions_eyesVert_max";
				global::haxe.root.EyeHeadGazeLogic.FORWARD = new global::glm.Vec3(new global::haxe.lang.Null<double>(((double) (0) ), true), new global::haxe.lang.Null<double>(((double) (0) ), true), new global::haxe.lang.Null<double>(((double) (-1) ), true));
				global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL = new global::glm.Vec3(new global::haxe.lang.Null<double>(((double) (0) ), true), new global::haxe.lang.Null<double>(((double) (1) ), true), new global::haxe.lang.Null<double>(((double) (0) ), true));
				global::haxe.root.EyeHeadGazeLogic.RIGHT = new global::glm.Vec3(new global::haxe.lang.Null<double>(((double) (-1) ), true), new global::haxe.lang.Null<double>(((double) (0) ), true), new global::haxe.lang.Null<double>(((double) (0) ), true));
				global::haxe.root.EyeHeadGazeLogic.VISEMES = new global::haxe.root.Array<object>(new object[]{global::haxe.root.EyeHeadGazeLogic.EYES_RIGHT, global::haxe.root.EyeHeadGazeLogic.EYES_LEFT, global::haxe.root.EyeHeadGazeLogic.EYES_DOWN, global::haxe.root.EyeHeadGazeLogic.EYES_UP});
				global::haxe.root.EyeHeadGazeLogic.EYES_MAX_YAW = 30.0;
				global::haxe.root.EyeHeadGazeLogic.EYES_MAX_PITCH = 12.0;
				global::haxe.root.EyeHeadGazeLogic.NECK_MAX_PITCH = 45.0;
				global::haxe.root.EyeHeadGazeLogic.NECK_MIN_PITCH = -40.0;
				global::haxe.root.EyeHeadGazeLogic.NECK_MAX_YAW = 60.0;
				global::haxe.root.EyeHeadGazeLogic.NECK_MIN_YAW = -60.0;
			}
		}
		
		
		public EyeHeadGazeLogic(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public EyeHeadGazeLogic(global::glm.Quat aPoseLeftEyeRotation, global::glm.Quat aPoseRightEyeRotation, global::glm.Quat aPoseNeckRotation) {
			global::haxe.root.EyeHeadGazeLogic.__hx_ctor__EyeHeadGazeLogic(this, aPoseLeftEyeRotation, aPoseRightEyeRotation, aPoseNeckRotation);
		}
		
		
		public static void __hx_ctor__EyeHeadGazeLogic(global::haxe.root.EyeHeadGazeLogic __hx_this, global::glm.Quat aPoseLeftEyeRotation, global::glm.Quat aPoseRightEyeRotation, global::glm.Quat aPoseNeckRotation) {
			__hx_this.eyeGazeTargetPoint = null;
			__hx_this.neckRestTendencyStrenght = 0.25;
			__hx_this.neckPitch = 0.0;
			__hx_this.neckYaw = 0.0;
			__hx_this.neckRotMaxSpeed = 135.0;
			__hx_this.neckRotTime = 0.1;
			__hx_this.enableNeckRotation = true;
			__hx_this.eyesYaw = 0.0;
			__hx_this.eyesPitch = 0.0;
			__hx_this.eyesRotSpeed = 1000.0;
			__hx_this.aPoseLeftEyeRotation = aPoseLeftEyeRotation;
			__hx_this.aPoseRightEyeRotation = aPoseRightEyeRotation;
			__hx_this.aPoseNeckRotation = aPoseNeckRotation;
		}
		
		
		public static string EYES_RIGHT;
		
		public static string EYES_LEFT;
		
		public static string EYES_DOWN;
		
		public static string EYES_UP;
		
		public static global::glm.Vec3 FORWARD;
		
		public static global::glm.Vec3 HORIZ_PLANE_NORMAL;
		
		public static global::glm.Vec3 RIGHT;
		
		public static void SetReferenceAxes(global::glm.Vec3 fwd, global::glm.Vec3 up, global::glm.Vec3 right) {
			global::haxe.root.EyeHeadGazeLogic.FORWARD = fwd;
			global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL = up;
			global::haxe.root.EyeHeadGazeLogic.RIGHT = right;
		}
		
		
		public static global::haxe.root.Array<object> VISEMES;
		
		public static int get_viseme_count() {
			return global::haxe.root.EyeHeadGazeLogic.VISEMES.length;
		}
		
		
		public static double EYES_MAX_YAW;
		
		public static double EYES_MAX_PITCH;
		
		public static double NECK_MAX_PITCH;
		
		public static double NECK_MIN_PITCH;
		
		public static double NECK_MAX_YAW;
		
		public static double NECK_MIN_YAW;
		
		public static double SmoothtInc(double delta, double time, double max_speed, double dt) {
			unchecked {
				if (( global::System.Math.Abs(((double) (delta) )) < 0.0001 )) {
					return 0.0;
				}
				
				double speed = ( delta / time );
				if (( speed > max_speed )) {
					speed = max_speed;
				}
				else if (( speed <  - (max_speed)  )) {
					speed =  - (max_speed) ;
				}
				
				double inc = ( speed * dt );
				if (( global::System.Math.Abs(((double) (inc) )) > global::System.Math.Abs(((double) (delta) )) )) {
					global::haxe.Log.trace.__hx_invoke2_o(default(double), "RotSmoothtInc: incrementing too much!!!", default(double), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"SmoothtInc", "EyeHeadGazeLogic", "EyeHeadGazeLogic.hx"}, new int[]{1981972957}, new double[]{((double) (140) )}));
					inc = delta;
				}
				
				return inc;
			}
		}
		
		
		public static double LinearInc(double delta, double speed, double dt) {
			unchecked {
				double inc = ( speed * dt );
				inc = global::System.Math.Min(((double) (inc) ), ((double) (global::System.Math.Abs(((double) (delta) ))) ));
				if (( delta < 0 )) {
					inc *= ((double) (-1) );
				}
				
				return inc;
			}
		}
		
		
		public static void main() {
			global::haxe.root.EyeHeadGazeLogic.local_test();
		}
		
		
		public static void local_test() {
			global::haxe.root.EyeHeadGazeLogic logic = new global::haxe.root.EyeHeadGazeLogic(new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>)), new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>)), new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>)));
		}
		
		
		public double eyesRotSpeed;
		
		public double eyesPitch;
		
		public double eyesYaw;
		
		public bool enableNeckRotation;
		
		public double neckRotTime;
		
		public double neckRotMaxSpeed;
		
		public double neckYaw;
		
		public double neckPitch;
		
		public double neckRestTendencyStrenght;
		
		public global::glm.Vec3 eyeGazeTargetPoint;
		
		public global::glm.Quat aPoseLeftEyeRotation;
		
		public global::glm.Quat aPoseRightEyeRotation;
		
		public global::glm.Quat aPoseNeckRotation;
		
		public virtual void LookAtPoint(global::glm.Vec3 targetPoint) {
			this.eyeGazeTargetPoint = targetPoint;
		}
		
		
		public virtual void UpdateEyesRotation(global::glm.Vec3 leftEyePosition, global::glm.Vec3 rightEyePosition, global::glm.Quat leftEyeRotation, global::glm.Quat rightEyeRotation, double[] outBlendShapeWeights, global::glm.Quat inOutNeckRotation, double dt) {
			unchecked {
				double newEyesPitch = 0.0;
				double newEyesYaw = 0.0;
				if (( this.eyeGazeTargetPoint != null )) {
					global::glm.Vec3 abs_target_point = this.eyeGazeTargetPoint;
					double eyeMidPoint_z = default(double);
					double eyeMidPoint_y = default(double);
					double eyeMidPoint_x = ( (( leftEyePosition.x + rightEyePosition.x )) / 2.0 );
					eyeMidPoint_y = ( (( leftEyePosition.y + rightEyePosition.y )) / 2.0 );
					eyeMidPoint_z = ( (( leftEyePosition.z + rightEyePosition.z )) / 2.0 );
					global::glm.Quat _this = this.aPoseLeftEyeRotation;
					global::glm.Quat dest = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double x = leftEyeRotation.x;
					double y = leftEyeRotation.y;
					double z = leftEyeRotation.z;
					double w = leftEyeRotation.w;
					double d = ( ( ( ( leftEyeRotation.x * leftEyeRotation.x ) + ( leftEyeRotation.y * leftEyeRotation.y ) ) + ( leftEyeRotation.z * leftEyeRotation.z ) ) + ( leftEyeRotation.w * leftEyeRotation.w ) );
					double oneOverD = ( (( d < global::glm.GLM.EPSILON )) ? (((double) (0) )) : (( 1 / d )) );
					dest.x = (  - (x)  * oneOverD );
					dest.y = (  - (y)  * oneOverD );
					dest.z = (  - (z)  * oneOverD );
					dest.w = ( w * oneOverD );
					global::glm.Quat _this1 = dest;
					global::glm.Vec3 dest1 = new global::glm.Vec3(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double num12 = ( _this1.x + _this1.x );
					double num2 = ( _this1.y + _this1.y );
					double num = ( _this1.z + _this1.z );
					double num11 = ( _this1.w * num12 );
					double num10 = ( _this1.w * num2 );
					double num9 = ( _this1.w * num );
					double num8 = ( _this1.x * num12 );
					double num7 = ( _this1.x * num2 );
					double num6 = ( _this1.x * num );
					double num5 = ( _this1.y * num2 );
					double num4 = ( _this1.y * num );
					double num3 = ( _this1.z * num );
					double num15 = ( ( ( abs_target_point.x * (( ( 1.0 - num5 ) - num3 )) ) + ( abs_target_point.y * (( num7 - num9 )) ) ) + ( abs_target_point.z * (( num6 + num10 )) ) );
					double num14 = ( ( ( abs_target_point.x * (( num7 + num9 )) ) + ( abs_target_point.y * (( ( 1.0 - num8 ) - num3 )) ) ) + ( abs_target_point.z * (( num4 - num11 )) ) );
					double num13 = ( ( ( abs_target_point.x * (( num6 - num10 )) ) + ( abs_target_point.y * (( num4 + num11 )) ) ) + ( abs_target_point.z * (( ( 1.0 - num8 ) - num5 )) ) );
					dest1.x = num15;
					dest1.y = num14;
					dest1.z = num13;
					global::glm.Vec3 v = dest1;
					global::glm.Vec3 dest2 = new global::glm.Vec3(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double num121 = ( _this.x + _this.x );
					double num21 = ( _this.y + _this.y );
					double num1 = ( _this.z + _this.z );
					double num111 = ( _this.w * num121 );
					double num101 = ( _this.w * num21 );
					double num91 = ( _this.w * num1 );
					double num81 = ( _this.x * num121 );
					double num71 = ( _this.x * num21 );
					double num61 = ( _this.x * num1 );
					double num51 = ( _this.y * num21 );
					double num41 = ( _this.y * num1 );
					double num31 = ( _this.z * num1 );
					double num151 = ( ( ( v.x * (( ( 1.0 - num51 ) - num31 )) ) + ( v.y * (( num71 - num91 )) ) ) + ( v.z * (( num61 + num101 )) ) );
					double num141 = ( ( ( v.x * (( num71 + num91 )) ) + ( v.y * (( ( 1.0 - num81 ) - num31 )) ) ) + ( v.z * (( num41 - num111 )) ) );
					double num131 = ( ( ( v.x * (( num61 - num101 )) ) + ( v.y * (( num41 + num111 )) ) ) + ( v.z * (( ( 1.0 - num81 ) - num51 )) ) );
					dest2.x = num151;
					dest2.y = num141;
					dest2.z = num131;
					global::glm.Vec3 targetPointInvDelta = dest2;
					global::glm.Quat _this2 = this.aPoseLeftEyeRotation;
					global::glm.Quat dest3 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double x1 = leftEyeRotation.x;
					double y1 = leftEyeRotation.y;
					double z1 = leftEyeRotation.z;
					double w1 = leftEyeRotation.w;
					double d1 = ( ( ( ( leftEyeRotation.x * leftEyeRotation.x ) + ( leftEyeRotation.y * leftEyeRotation.y ) ) + ( leftEyeRotation.z * leftEyeRotation.z ) ) + ( leftEyeRotation.w * leftEyeRotation.w ) );
					double oneOverD1 = ( (( d1 < global::glm.GLM.EPSILON )) ? (((double) (0) )) : (( 1 / d1 )) );
					dest3.x = (  - (x1)  * oneOverD1 );
					dest3.y = (  - (y1)  * oneOverD1 );
					dest3.z = (  - (z1)  * oneOverD1 );
					dest3.w = ( w1 * oneOverD1 );
					global::glm.Quat _this3 = dest3;
					global::glm.Vec3 dest4 = new global::glm.Vec3(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double num122 = ( _this3.x + _this3.x );
					double num22 = ( _this3.y + _this3.y );
					double num16 = ( _this3.z + _this3.z );
					double num112 = ( _this3.w * num122 );
					double num102 = ( _this3.w * num22 );
					double num92 = ( _this3.w * num16 );
					double num82 = ( _this3.x * num122 );
					double num72 = ( _this3.x * num22 );
					double num62 = ( _this3.x * num16 );
					double num52 = ( _this3.y * num22 );
					double num42 = ( _this3.y * num16 );
					double num32 = ( _this3.z * num16 );
					double num152 = ( ( ( eyeMidPoint_x * (( ( 1.0 - num52 ) - num32 )) ) + ( eyeMidPoint_y * (( num72 - num92 )) ) ) + ( eyeMidPoint_z * (( num62 + num102 )) ) );
					double num142 = ( ( ( eyeMidPoint_x * (( num72 + num92 )) ) + ( eyeMidPoint_y * (( ( 1.0 - num82 ) - num32 )) ) ) + ( eyeMidPoint_z * (( num42 - num112 )) ) );
					double num132 = ( ( ( eyeMidPoint_x * (( num62 - num102 )) ) + ( eyeMidPoint_y * (( num42 + num112 )) ) ) + ( eyeMidPoint_z * (( ( 1.0 - num82 ) - num52 )) ) );
					dest4.x = num152;
					dest4.y = num142;
					dest4.z = num132;
					global::glm.Vec3 v1 = dest4;
					global::glm.Vec3 dest5 = new global::glm.Vec3(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double num123 = ( _this2.x + _this2.x );
					double num23 = ( _this2.y + _this2.y );
					double num17 = ( _this2.z + _this2.z );
					double num113 = ( _this2.w * num123 );
					double num103 = ( _this2.w * num23 );
					double num93 = ( _this2.w * num17 );
					double num83 = ( _this2.x * num123 );
					double num73 = ( _this2.x * num23 );
					double num63 = ( _this2.x * num17 );
					double num53 = ( _this2.y * num23 );
					double num43 = ( _this2.y * num17 );
					double num33 = ( _this2.z * num17 );
					double num153 = ( ( ( v1.x * (( ( 1.0 - num53 ) - num33 )) ) + ( v1.y * (( num73 - num93 )) ) ) + ( v1.z * (( num63 + num103 )) ) );
					double num143 = ( ( ( v1.x * (( num73 + num93 )) ) + ( v1.y * (( ( 1.0 - num83 ) - num33 )) ) ) + ( v1.z * (( num43 - num113 )) ) );
					double num133 = ( ( ( v1.x * (( num63 - num103 )) ) + ( v1.y * (( num43 + num113 )) ) ) + ( v1.z * (( ( 1.0 - num83 ) - num53 )) ) );
					dest5.x = num153;
					dest5.y = num143;
					dest5.z = num133;
					global::glm.Vec3 eyeMidPointInvDelta = dest5;
					global::glm.Vec3 dest6 = new global::glm.Vec3(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					dest6.x = ( targetPointInvDelta.x - eyeMidPointInvDelta.x );
					dest6.y = ( targetPointInvDelta.y - eyeMidPointInvDelta.y );
					dest6.z = ( targetPointInvDelta.z - eyeMidPointInvDelta.z );
					global::glm.Vec3 targetPointEyeSpace = dest6;
					double hproj_dist = ( ( ( targetPointEyeSpace.x * global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL.x ) + ( targetPointEyeSpace.y * global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL.y ) ) + ( targetPointEyeSpace.z * global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL.z ) );
					global::glm.Vec3 a = global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL;
					global::glm.Vec3 dest7 = new global::glm.Vec3(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					dest7.x = ( a.x * hproj_dist );
					dest7.y = ( a.y * hproj_dist );
					dest7.z = ( a.z * hproj_dist );
					global::glm.Vec3 v2 = dest7;
					global::glm.Vec3 dest8 = new global::glm.Vec3(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					dest8.x = ( targetPointEyeSpace.x - v2.x );
					dest8.y = ( targetPointEyeSpace.y - v2.y );
					dest8.z = ( targetPointEyeSpace.z - v2.z );
					global::glm.Vec3 targetHplaneProjection = dest8;
					double dot = ( ( ( targetPointEyeSpace.x * targetHplaneProjection.x ) + ( targetPointEyeSpace.y * targetHplaneProjection.y ) ) + ( targetPointEyeSpace.z * targetHplaneProjection.z ) );
					dot /= ( global::System.Math.Sqrt(((double) (( ( ( targetPointEyeSpace.x * targetPointEyeSpace.x ) + ( targetPointEyeSpace.y * targetPointEyeSpace.y ) ) + ( targetPointEyeSpace.z * targetPointEyeSpace.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( targetHplaneProjection.x * targetHplaneProjection.x ) + ( targetHplaneProjection.y * targetHplaneProjection.y ) ) + ( targetHplaneProjection.z * targetHplaneProjection.z ) )) )) );
					double angle = global::System.Math.Acos(((double) (dot) ));
					double vertAngleBetween = ( ( angle * 180 ) / global::haxe.root.Math.PI );
					global::glm.Vec3 b = global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL;
					if (( ( ( ( targetPointEyeSpace.x * b.x ) + ( targetPointEyeSpace.y * b.y ) ) + ( targetPointEyeSpace.z * b.z ) ) >= 0 )) {
						newEyesPitch = vertAngleBetween;
					}
					else {
						newEyesPitch =  - (vertAngleBetween) ;
					}
					
					global::glm.Vec3 a1 = global::haxe.root.EyeHeadGazeLogic.FORWARD;
					double dot1 = ( ( ( a1.x * targetHplaneProjection.x ) + ( a1.y * targetHplaneProjection.y ) ) + ( a1.z * targetHplaneProjection.z ) );
					dot1 /= ( global::System.Math.Sqrt(((double) (( ( ( a1.x * a1.x ) + ( a1.y * a1.y ) ) + ( a1.z * a1.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( targetHplaneProjection.x * targetHplaneProjection.x ) + ( targetHplaneProjection.y * targetHplaneProjection.y ) ) + ( targetHplaneProjection.z * targetHplaneProjection.z ) )) )) );
					double angle1 = global::System.Math.Acos(((double) (dot1) ));
					double horizAngleBetween = ( ( angle1 * 180 ) / global::haxe.root.Math.PI );
					global::glm.Vec3 b1 = global::haxe.root.EyeHeadGazeLogic.RIGHT;
					if (( ( ( ( targetHplaneProjection.x * b1.x ) + ( targetHplaneProjection.y * b1.y ) ) + ( targetHplaneProjection.z * b1.z ) ) <= 0 )) {
						newEyesYaw = horizAngleBetween;
					}
					else {
						newEyesYaw =  - (horizAngleBetween) ;
					}
					
				}
				
				double deltaEyesPitch = ( newEyesPitch - this.eyesPitch );
				double deltaEyesYaw = ( newEyesYaw - this.eyesYaw );
				this.eyesPitch += global::haxe.root.EyeHeadGazeLogic.LinearInc(deltaEyesPitch, this.eyesRotSpeed, dt);
				this.eyesYaw += global::haxe.root.EyeHeadGazeLogic.LinearInc(deltaEyesYaw, this.eyesRotSpeed, dt);
				if (this.enableNeckRotation) {
					double deltaPitch = 0.0;
					if (( this.eyesPitch > global::haxe.root.EyeHeadGazeLogic.EYES_MAX_PITCH )) {
						deltaPitch = ( this.eyesPitch - global::haxe.root.EyeHeadGazeLogic.EYES_MAX_PITCH );
						this.eyesPitch = global::haxe.root.EyeHeadGazeLogic.EYES_MAX_PITCH;
					}
					else if (( this.eyesPitch <  - (global::haxe.root.EyeHeadGazeLogic.EYES_MAX_PITCH)  )) {
						deltaPitch = ( this.eyesPitch + global::haxe.root.EyeHeadGazeLogic.EYES_MAX_PITCH );
						this.eyesPitch =  - (global::haxe.root.EyeHeadGazeLogic.EYES_MAX_PITCH) ;
					}
					
					this.neckPitch += global::haxe.root.EyeHeadGazeLogic.SmoothtInc(deltaPitch, this.neckRotTime, this.neckRotMaxSpeed, dt);
					this.neckPitch += global::haxe.root.EyeHeadGazeLogic.SmoothtInc( - (this.neckPitch) , ( this.neckRotTime / this.neckRestTendencyStrenght ), ( this.neckRotMaxSpeed * this.neckRestTendencyStrenght ), dt);
					if (( this.neckPitch > global::haxe.root.EyeHeadGazeLogic.NECK_MAX_PITCH )) {
						this.neckPitch = global::haxe.root.EyeHeadGazeLogic.NECK_MAX_PITCH;
					}
					else if (( this.neckPitch < global::haxe.root.EyeHeadGazeLogic.NECK_MIN_PITCH )) {
						this.neckPitch = global::haxe.root.EyeHeadGazeLogic.NECK_MIN_PITCH;
					}
					
					double deltaYaw = 0.0;
					if (( this.eyesYaw >= global::haxe.root.EyeHeadGazeLogic.EYES_MAX_YAW )) {
						deltaYaw = ( this.eyesYaw - global::haxe.root.EyeHeadGazeLogic.EYES_MAX_YAW );
						this.eyesYaw = global::haxe.root.EyeHeadGazeLogic.EYES_MAX_YAW;
					}
					else if (( this.eyesYaw <=  - (global::haxe.root.EyeHeadGazeLogic.EYES_MAX_YAW)  )) {
						deltaYaw = ( this.eyesYaw + global::haxe.root.EyeHeadGazeLogic.EYES_MAX_YAW );
						this.eyesYaw =  - (global::haxe.root.EyeHeadGazeLogic.EYES_MAX_YAW) ;
					}
					
					this.neckYaw += global::haxe.root.EyeHeadGazeLogic.SmoothtInc(deltaYaw, this.neckRotTime, this.neckRotMaxSpeed, dt);
					this.neckYaw += global::haxe.root.EyeHeadGazeLogic.SmoothtInc( - (this.neckYaw) , ( this.neckRotTime / this.neckRestTendencyStrenght ), ( this.neckRotMaxSpeed * this.neckRestTendencyStrenght ), dt);
					if (( this.neckYaw > global::haxe.root.EyeHeadGazeLogic.NECK_MAX_YAW )) {
						this.neckYaw = global::haxe.root.EyeHeadGazeLogic.NECK_MAX_YAW;
					}
					else if (( this.neckYaw < global::haxe.root.EyeHeadGazeLogic.NECK_MIN_YAW )) {
						this.neckYaw = global::haxe.root.EyeHeadGazeLogic.NECK_MIN_YAW;
					}
					
					double neckPitchRad = ( ( this.neckPitch * global::haxe.root.Math.PI ) / 180 );
					double neckYawRad = ( ( this.neckYaw * global::haxe.root.Math.PI ) / 180 );
					global::glm.Quat _this4 = this.aPoseNeckRotation;
					global::glm.Quat dest9 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double x2 = _this4.x;
					double y2 = _this4.y;
					double z2 = _this4.z;
					double w2 = _this4.w;
					double d2 = ( ( ( ( _this4.x * _this4.x ) + ( _this4.y * _this4.y ) ) + ( _this4.z * _this4.z ) ) + ( _this4.w * _this4.w ) );
					double oneOverD2 = ( (( d2 < global::glm.GLM.EPSILON )) ? (((double) (0) )) : (( 1 / d2 )) );
					dest9.x = (  - (x2)  * oneOverD2 );
					dest9.y = (  - (y2)  * oneOverD2 );
					dest9.z = (  - (z2)  * oneOverD2 );
					dest9.w = ( w2 * oneOverD2 );
					global::glm.Quat q = dest9;
					global::glm.Quat dest10 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double ax = inOutNeckRotation.x;
					double ay = inOutNeckRotation.y;
					double az = inOutNeckRotation.z;
					double aw = inOutNeckRotation.w;
					double bx = q.x;
					double @by = q.y;
					double bz = q.z;
					double bw = q.w;
					dest10.x = ( ( ( ( ax * bw ) + ( aw * bx ) ) + ( ay * bz ) ) - ( az * @by ) );
					dest10.y = ( ( ( ( ay * bw ) + ( aw * @by ) ) + ( az * bx ) ) - ( ax * bz ) );
					dest10.z = ( ( ( ( az * bw ) + ( aw * bz ) ) + ( ax * @by ) ) - ( ay * bx ) );
					dest10.w = ( ( ( ( aw * bw ) - ( ax * bx ) ) - ( ay * @by ) ) - ( az * bz ) );
					global::glm.Quat neckAbsDelta = dest10;
					global::glm.Quat yawQuat = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					{
						global::glm.Vec3 axis = global::haxe.root.EyeHeadGazeLogic.HORIZ_PLANE_NORMAL;
						double angle2 =  - (neckYawRad) ;
						angle2 *= 0.5;
						double s = global::System.Math.Sin(((double) (angle2) ));
						yawQuat.x = ( s * axis.x );
						yawQuat.y = ( s * axis.y );
						yawQuat.z = ( s * axis.z );
						yawQuat.w = global::System.Math.Cos(((double) (angle2) ));
					}
					
					global::glm.Quat dest11 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double x3 = neckAbsDelta.x;
					double y3 = neckAbsDelta.y;
					double z3 = neckAbsDelta.z;
					double w3 = neckAbsDelta.w;
					double d3 = ( ( ( ( neckAbsDelta.x * neckAbsDelta.x ) + ( neckAbsDelta.y * neckAbsDelta.y ) ) + ( neckAbsDelta.z * neckAbsDelta.z ) ) + ( neckAbsDelta.w * neckAbsDelta.w ) );
					double oneOverD3 = ( (( d3 < global::glm.GLM.EPSILON )) ? (((double) (0) )) : (( 1 / d3 )) );
					dest11.x = (  - (x3)  * oneOverD3 );
					dest11.y = (  - (y3)  * oneOverD3 );
					dest11.z = (  - (z3)  * oneOverD3 );
					dest11.w = ( w3 * oneOverD3 );
					global::glm.Quat q1 = dest11;
					global::glm.Quat dest12 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double ax1 = yawQuat.x;
					double ay1 = yawQuat.y;
					double az1 = yawQuat.z;
					double aw1 = yawQuat.w;
					double bx1 = q1.x;
					double by1 = q1.y;
					double bz1 = q1.z;
					double bw1 = q1.w;
					dest12.x = ( ( ( ( ax1 * bw1 ) + ( aw1 * bx1 ) ) + ( ay1 * bz1 ) ) - ( az1 * by1 ) );
					dest12.y = ( ( ( ( ay1 * bw1 ) + ( aw1 * by1 ) ) + ( az1 * bx1 ) ) - ( ax1 * bz1 ) );
					dest12.z = ( ( ( ( az1 * bw1 ) + ( aw1 * bz1 ) ) + ( ax1 * by1 ) ) - ( ay1 * bx1 ) );
					dest12.w = ( ( ( ( aw1 * bw1 ) - ( ax1 * bx1 ) ) - ( ay1 * by1 ) ) - ( az1 * bz1 ) );
					global::glm.Quat q2 = dest12;
					global::glm.Quat dest13 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double ax2 = neckAbsDelta.x;
					double ay2 = neckAbsDelta.y;
					double az2 = neckAbsDelta.z;
					double aw2 = neckAbsDelta.w;
					double bx2 = q2.x;
					double by2 = q2.y;
					double bz2 = q2.z;
					double bw2 = q2.w;
					dest13.x = ( ( ( ( ax2 * bw2 ) + ( aw2 * bx2 ) ) + ( ay2 * bz2 ) ) - ( az2 * by2 ) );
					dest13.y = ( ( ( ( ay2 * bw2 ) + ( aw2 * by2 ) ) + ( az2 * bx2 ) ) - ( ax2 * bz2 ) );
					dest13.z = ( ( ( ( az2 * bw2 ) + ( aw2 * bz2 ) ) + ( ax2 * by2 ) ) - ( ay2 * bx2 ) );
					dest13.w = ( ( ( ( aw2 * bw2 ) - ( ax2 * bx2 ) ) - ( ay2 * by2 ) ) - ( az2 * bz2 ) );
					global::glm.Quat yawGlobal = dest13;
					global::glm.Quat pitchQuat = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					{
						global::glm.Vec3 axis1 = global::haxe.root.EyeHeadGazeLogic.RIGHT;
						double angle3 =  - (neckPitchRad) ;
						angle3 *= 0.5;
						double s1 = global::System.Math.Sin(((double) (angle3) ));
						pitchQuat.x = ( s1 * axis1.x );
						pitchQuat.y = ( s1 * axis1.y );
						pitchQuat.z = ( s1 * axis1.z );
						pitchQuat.w = global::System.Math.Cos(((double) (angle3) ));
					}
					
					global::glm.Quat dest14 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double x4 = neckAbsDelta.x;
					double y4 = neckAbsDelta.y;
					double z4 = neckAbsDelta.z;
					double w4 = neckAbsDelta.w;
					double d4 = ( ( ( ( neckAbsDelta.x * neckAbsDelta.x ) + ( neckAbsDelta.y * neckAbsDelta.y ) ) + ( neckAbsDelta.z * neckAbsDelta.z ) ) + ( neckAbsDelta.w * neckAbsDelta.w ) );
					double oneOverD4 = ( (( d4 < global::glm.GLM.EPSILON )) ? (((double) (0) )) : (( 1 / d4 )) );
					dest14.x = (  - (x4)  * oneOverD4 );
					dest14.y = (  - (y4)  * oneOverD4 );
					dest14.z = (  - (z4)  * oneOverD4 );
					dest14.w = ( w4 * oneOverD4 );
					global::glm.Quat q3 = dest14;
					global::glm.Quat dest15 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double ax3 = pitchQuat.x;
					double ay3 = pitchQuat.y;
					double az3 = pitchQuat.z;
					double aw3 = pitchQuat.w;
					double bx3 = q3.x;
					double by3 = q3.y;
					double bz3 = q3.z;
					double bw3 = q3.w;
					dest15.x = ( ( ( ( ax3 * bw3 ) + ( aw3 * bx3 ) ) + ( ay3 * bz3 ) ) - ( az3 * by3 ) );
					dest15.y = ( ( ( ( ay3 * bw3 ) + ( aw3 * by3 ) ) + ( az3 * bx3 ) ) - ( ax3 * bz3 ) );
					dest15.z = ( ( ( ( az3 * bw3 ) + ( aw3 * bz3 ) ) + ( ax3 * by3 ) ) - ( ay3 * bx3 ) );
					dest15.w = ( ( ( ( aw3 * bw3 ) - ( ax3 * bx3 ) ) - ( ay3 * by3 ) ) - ( az3 * bz3 ) );
					global::glm.Quat q4 = dest15;
					global::glm.Quat dest16 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double ax4 = neckAbsDelta.x;
					double ay4 = neckAbsDelta.y;
					double az4 = neckAbsDelta.z;
					double aw4 = neckAbsDelta.w;
					double bx4 = q4.x;
					double by4 = q4.y;
					double bz4 = q4.z;
					double bw4 = q4.w;
					dest16.x = ( ( ( ( ax4 * bw4 ) + ( aw4 * bx4 ) ) + ( ay4 * bz4 ) ) - ( az4 * by4 ) );
					dest16.y = ( ( ( ( ay4 * bw4 ) + ( aw4 * by4 ) ) + ( az4 * bx4 ) ) - ( ax4 * bz4 ) );
					dest16.z = ( ( ( ( az4 * bw4 ) + ( aw4 * bz4 ) ) + ( ax4 * by4 ) ) - ( ay4 * bx4 ) );
					dest16.w = ( ( ( ( aw4 * bw4 ) - ( ax4 * bx4 ) ) - ( ay4 * by4 ) ) - ( az4 * bz4 ) );
					global::glm.Quat pitchGlobal = dest16;
					{
						global::glm.Quat q5 = this.aPoseNeckRotation;
						global::glm.Quat dest17 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
						double ax5 = yawGlobal.x;
						double ay5 = yawGlobal.y;
						double az5 = yawGlobal.z;
						double aw5 = yawGlobal.w;
						double bx5 = q5.x;
						double by5 = q5.y;
						double bz5 = q5.z;
						double bw5 = q5.w;
						dest17.x = ( ( ( ( ax5 * bw5 ) + ( aw5 * bx5 ) ) + ( ay5 * bz5 ) ) - ( az5 * by5 ) );
						dest17.y = ( ( ( ( ay5 * bw5 ) + ( aw5 * by5 ) ) + ( az5 * bx5 ) ) - ( ax5 * bz5 ) );
						dest17.z = ( ( ( ( az5 * bw5 ) + ( aw5 * bz5 ) ) + ( ax5 * by5 ) ) - ( ay5 * bx5 ) );
						dest17.w = ( ( ( ( aw5 * bw5 ) - ( ax5 * bx5 ) ) - ( ay5 * by5 ) ) - ( az5 * bz5 ) );
						global::glm.Quat q6 = dest17;
						global::glm.Quat dest18 = new global::glm.Quat(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
						double ax6 = pitchGlobal.x;
						double ay6 = pitchGlobal.y;
						double az6 = pitchGlobal.z;
						double aw6 = pitchGlobal.w;
						double bx6 = q6.x;
						double by6 = q6.y;
						double bz6 = q6.z;
						double bw6 = q6.w;
						dest18.x = ( ( ( ( ax6 * bw6 ) + ( aw6 * bx6 ) ) + ( ay6 * bz6 ) ) - ( az6 * by6 ) );
						dest18.y = ( ( ( ( ay6 * bw6 ) + ( aw6 * by6 ) ) + ( az6 * bx6 ) ) - ( ax6 * bz6 ) );
						dest18.z = ( ( ( ( az6 * bw6 ) + ( aw6 * bz6 ) ) + ( ax6 * by6 ) ) - ( ay6 * bx6 ) );
						dest18.w = ( ( ( ( aw6 * bw6 ) - ( ax6 * bx6 ) ) - ( ay6 * by6 ) ) - ( az6 * bz6 ) );
						global::glm.Quat q7 = dest18;
						inOutNeckRotation.x = q7.x;
						inOutNeckRotation.y = q7.y;
						inOutNeckRotation.z = q7.z;
						inOutNeckRotation.w = q7.w;
					}
					
				}
				
				double weightEyesPitch = ( ( 0.5 * this.eyesPitch ) / 45.0 );
				double weightEyesYaw = ( ( 0.5 * this.eyesYaw ) / 52.0 );
				if (( weightEyesPitch >= 0.0 )) {
					((double[]) (outBlendShapeWeights) )[3] = weightEyesPitch;
					((double[]) (outBlendShapeWeights) )[2] = 0.0;
				}
				else {
					((double[]) (outBlendShapeWeights) )[2] =  - (weightEyesPitch) ;
					((double[]) (outBlendShapeWeights) )[3] = 0.0;
				}
				
				if (( weightEyesYaw >= 0.0 )) {
					((double[]) (outBlendShapeWeights) )[0] = weightEyesYaw;
					((double[]) (outBlendShapeWeights) )[1] = 0.0;
				}
				else {
					((double[]) (outBlendShapeWeights) )[1] =  - (weightEyesYaw) ;
					((double[]) (outBlendShapeWeights) )[0] = 0.0;
				}
				
			}
		}
		
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 2027913330:
					{
						this.neckRestTendencyStrenght = ((double) (@value) );
						return @value;
					}
					
					
					case 1735186593:
					{
						this.neckPitch = ((double) (@value) );
						return @value;
					}
					
					
					case 133011536:
					{
						this.neckYaw = ((double) (@value) );
						return @value;
					}
					
					
					case 152597275:
					{
						this.neckRotMaxSpeed = ((double) (@value) );
						return @value;
					}
					
					
					case 1848838373:
					{
						this.neckRotTime = ((double) (@value) );
						return @value;
					}
					
					
					case 1021739245:
					{
						this.eyesYaw = ((double) (@value) );
						return @value;
					}
					
					
					case 2061951614:
					{
						this.eyesPitch = ((double) (@value) );
						return @value;
					}
					
					
					case 1231967730:
					{
						this.eyesRotSpeed = ((double) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 961976175:
					{
						this.aPoseNeckRotation = ((global::glm.Quat) (@value) );
						return @value;
					}
					
					
					case 118625989:
					{
						this.aPoseRightEyeRotation = ((global::glm.Quat) (@value) );
						return @value;
					}
					
					
					case 473288150:
					{
						this.aPoseLeftEyeRotation = ((global::glm.Quat) (@value) );
						return @value;
					}
					
					
					case 998101385:
					{
						this.eyeGazeTargetPoint = ((global::glm.Vec3) (@value) );
						return @value;
					}
					
					
					case 2027913330:
					{
						this.neckRestTendencyStrenght = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 1735186593:
					{
						this.neckPitch = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 133011536:
					{
						this.neckYaw = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 152597275:
					{
						this.neckRotMaxSpeed = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 1848838373:
					{
						this.neckRotTime = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 2010371616:
					{
						this.enableNeckRotation = global::haxe.lang.Runtime.toBool(@value);
						return @value;
					}
					
					
					case 1021739245:
					{
						this.eyesYaw = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 2061951614:
					{
						this.eyesPitch = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 1231967730:
					{
						this.eyesRotSpeed = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 121749769:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "UpdateEyesRotation", 121749769)) );
					}
					
					
					case 1261056414:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "LookAtPoint", 1261056414)) );
					}
					
					
					case 961976175:
					{
						return this.aPoseNeckRotation;
					}
					
					
					case 118625989:
					{
						return this.aPoseRightEyeRotation;
					}
					
					
					case 473288150:
					{
						return this.aPoseLeftEyeRotation;
					}
					
					
					case 998101385:
					{
						return this.eyeGazeTargetPoint;
					}
					
					
					case 2027913330:
					{
						return this.neckRestTendencyStrenght;
					}
					
					
					case 1735186593:
					{
						return this.neckPitch;
					}
					
					
					case 133011536:
					{
						return this.neckYaw;
					}
					
					
					case 152597275:
					{
						return this.neckRotMaxSpeed;
					}
					
					
					case 1848838373:
					{
						return this.neckRotTime;
					}
					
					
					case 2010371616:
					{
						return this.enableNeckRotation;
					}
					
					
					case 1021739245:
					{
						return this.eyesYaw;
					}
					
					
					case 2061951614:
					{
						return this.eyesPitch;
					}
					
					
					case 1231967730:
					{
						return this.eyesRotSpeed;
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 2027913330:
					{
						return this.neckRestTendencyStrenght;
					}
					
					
					case 1735186593:
					{
						return this.neckPitch;
					}
					
					
					case 133011536:
					{
						return this.neckYaw;
					}
					
					
					case 152597275:
					{
						return this.neckRotMaxSpeed;
					}
					
					
					case 1848838373:
					{
						return this.neckRotTime;
					}
					
					
					case 1021739245:
					{
						return this.eyesYaw;
					}
					
					
					case 2061951614:
					{
						return this.eyesPitch;
					}
					
					
					case 1231967730:
					{
						return this.eyesRotSpeed;
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, global::haxe.root.Array dynargs) {
			unchecked {
				switch (hash) {
					case 121749769:
					{
						this.UpdateEyesRotation(((global::glm.Vec3) (dynargs[0]) ), ((global::glm.Vec3) (dynargs[1]) ), ((global::glm.Quat) (dynargs[2]) ), ((global::glm.Quat) (dynargs[3]) ), ((double[]) (dynargs[4]) ), ((global::glm.Quat) (dynargs[5]) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[6])) ));
						break;
					}
					
					
					case 1261056414:
					{
						this.LookAtPoint(((global::glm.Vec3) (dynargs[0]) ));
						break;
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
		public override void __hx_getFields(global::haxe.root.Array<object> baseArr) {
			baseArr.push("aPoseNeckRotation");
			baseArr.push("aPoseRightEyeRotation");
			baseArr.push("aPoseLeftEyeRotation");
			baseArr.push("eyeGazeTargetPoint");
			baseArr.push("neckRestTendencyStrenght");
			baseArr.push("neckPitch");
			baseArr.push("neckYaw");
			baseArr.push("neckRotMaxSpeed");
			baseArr.push("neckRotTime");
			baseArr.push("enableNeckRotation");
			baseArr.push("eyesYaw");
			baseArr.push("eyesPitch");
			baseArr.push("eyesRotSpeed");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


